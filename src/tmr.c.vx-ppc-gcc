#ifndef TMR_C_VX_XXX_XXX
#define TMR_C_VX_XXX_XXX


#include <stdio.h>
#include <taskLib.h>
#include <sysLib.h>

#include "src/tmr.h"


/* ---------------------------------------------------------------------- *//*!

  \def _33MHZ Symbol for 33.333333MHZ
                                                                          *//*!
  \def _50MHZ Symbol for 50.000000MHZ
                                                                          *//*!
  \def _60MHZ Symbol for 60.000000MHZ
                                                                          *//*!
  \def _66MHZ Symbol for 66.666666MHZ

   These are the target bus speeds of the known processors
                                                                          */
/* ---------------------------------------------------------------------- */
#define _33MHZ 33333333
#define _50MHZ 50000000
#define _60MHZ 60000000
#define _66MHZ 66666666



/* ---------------------------------------------------------------------- *//*!

  \def    isFreq(_measured, _target)
  \brief  Tests whether the measured frequency is consistent with the 
          target frequency.

   The measuring method will always error on the low side, so the measured
   frequency must be between the target frequency and the target frequency
   - some margin, typically ~7.

   The error should be go like the 1/number of VxWorks in a second. This
   is because the taskDelay request can start on any arbitrary place
   with respect to the VxWorks time. Worse case it can start arbitrarily
   close to the next tick expiring. This means the frequency will by
   off by as much as one clock tick. I tried to observe this, but was
   semi-unsuccessful. The error clearly went down as the VxWorks clock
   frequency was turned up, but I could not get a handle on the absolute
   units. 

   I was a little hesitant to temporarily up the clock frequency. The
   tolerances I picked seem to work okay with a frequency as low as
   60 Hz, the typical VxWorks clock. (Although a couple came a little
   close to the lower bound, I never saw it fail.)


                                                                          */
/* ---------------------------------------------------------------------- */
#define isFreq(_f, _t) ((_f >= _t * .92 / 4 ) && (_f <= _t / 4 ))
/* ---------------------------------------------------------------------- */




struct _TMR_parameters
{
    int frequency;          /*!< Number of ticks in a second                 */
    int nsecs_per_tick;     /*!< Number of nsecs/tick (roughly)              */
    int nsecs_per_tick_num; /*!< More accurate conversion factor, numerator  */
    int nsecs_per_tick_den; /*!< More accurate conversion factor, denominator*/
};


typedef struct _TMR_parameters TMR_parameters;
static  struct _TMR_parameters TMR_Parameters = {0, 0, 0, 0};



int TMR_initialize (void)
/*
   DESCRIPTION
   -----------
   Initializes the TMR parameter block. This is a one time call.

   PARAMETERS
   ----------
         NONE

   RETURNS
   -------
   Nothing
*/
{
   TMR_parameters *pp = &TMR_Parameters;
   TMR_tick frequency;
   int          ticks;
   int       fraction;


   /* 
    | Time 1/4 a second
    | Going lower  results in too big of a round off error.
    | Going higher just takes longer.
   */
   fraction   = 4;
   ticks      = sysClkRateGet () / fraction;
   frequency  = TMR_GET ();
   taskDelay (ticks);
   frequency  = (TMR_GET () - frequency) * fraction; 


   if (isFreq (frequency, _33MHZ)) 
   { 
       pp->frequency          = 8333333;
       pp->nsecs_per_tick     = 120;
       pp->nsecs_per_tick_num = 120;
       pp->nsecs_per_tick_den =   1;
   }
   else if (isFreq(frequency, _50MHZ))
   { 
       pp->frequency          = 12500000;
       pp->nsecs_per_tick     = 80;
       pp->nsecs_per_tick_num = 80;
       pp->nsecs_per_tick_den =  1;
   }
   else if (isFreq(frequency, _60MHZ))
   { 
       pp->frequency          = 15000000;
       pp->nsecs_per_tick     = 67;
       pp->nsecs_per_tick_num = 200;
       pp->nsecs_per_tick_den = 3;
   }
   else if (isFreq(frequency, _66MHZ))
   { 
       pp->frequency          = 16666667;
       pp->nsecs_per_tick     = 60;
       pp->nsecs_per_tick_num = 60;
       pp->nsecs_per_tick_den =  1;
   }
   else
   {
       /* Unknown bus speed returned */
       printf  ("TMR_initialize, unknown bus speed %d\n", 4 * frequency);
       return -1;
   }

   printf ("TMR_initialize\n"
           "Measured Frequency: %8d Hz\n"
           "Nominal  Frequency: %8d Hz\n"
           "Nseconds / tick   : %8d nsecs\n",
            frequency,	
            pp->frequency,
            pp->nsecs_per_tick);

   return 0;   
} 




TMR_tick TMR_nsecs_to_ticks (int nanoseconds)
/*
   DESCRIPTION
   -----------
   Convert a number of nanoseconds to ticks

   PARAMETERS
   ----------
  nanoseconds: The number of nanoseconds to convert into ticks.

   RETURNS
   -------
   The equivalent number of ticks
*/
{
   TMR_parameters *pp = &TMR_Parameters;
   int denominator    = pp->nsecs_per_tick_num;
   int numerator      = pp->nsecs_per_tick_den;
   TMR_tick ticks;

   ticks = ((nanoseconds + pp->nsecs_per_tick - 1)) * numerator / denominator;

   return ticks;
}



unsigned int TMR_ticks_to_nsecs (TMR_tick ticks)
/*
   DESCRIPTION
   -----------
   Convert a number of ticks into nanoseconds. So far, nanoseconds is a 
   finer resolution than a tick. The fastest tick is 40nsecs/tick. 
   Unfortunately one of the conversion does not have an integral number of
   nanoseconds per tick, so the conversion is done as multiplying by one
   number and dividing by another (so far the conversion factor is a 
   rational number.. 

   PARAMETERS
   ----------
  nanoseconds: The number of nanoseconds to convert into ticks.

   RETURNS
   -------
   The equivalent number of ticks
*/
{ 
   TMR_parameters *pp = &TMR_Parameters;
   int numerator      = pp->nsecs_per_tick_num;
   int denominator    = pp->nsecs_per_tick_den;
   int nanoseconds    = numerator * ticks;
   if (denominator != 1) nanoseconds /= denominator;

   return nanoseconds;
}

   

unsigned int TMR_frequency (void)
/*
    DESCRIPTION
    -----------
    Returns the frequency, in Hertz, of the processor clock. This is the
    number of ticks/sec.

    PARAMETERS
    ----------
          NONE

    RETURNS
    -------
    The frequency in Hertz
*/
{   
    return TMR_Parameters.frequency;
}

#endif
