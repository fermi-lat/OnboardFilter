#ifndef TMR_C_UX_XXX_XXX
#define TMR_C_UX_XXX_XXX


/*----------------------------------------------------------------------- *//*!

    \file   tmr.c.ux-xxx-xxx
    \brief  Provides the implementation of the generic UNIX timing 
            routines.
    \author JJRussell - russell@slac.stanford.edu

\verbatim

CVS $Id
\endverbatim
									  */
/*----------------------------------------------------------------------- */


#include "src/tmr.h"

int TMR_initialize (void)
/*
   DESCRIPTION
   -----------
   Initializes the TMR parameter block. For the generic implementation
   this is a NOOP.

   PARAMETERS
   ----------
         NONE

   RETURNS
   -------
   Nothing
*/
{
   return 0;
} 



TMR_tick TMR_nsecs_to_ticks (int nanoseconds)
/*
   DESCRIPTION
   -----------
   Convert a number of nanoseconds to ticks.

   PARAMETERS
   ----------
  nanoseconds: The number of nanoseconds to convert to ticks.

   RETURNS
   -------
   The equivalent number of ticks
*/
{
   unsigned int usec;
   unsigned int  sec;
   TMR_tick    ticks;

   /* Round to usecs */
   usec          = (nanoseconds + 500)/ 1000;
   sec           = usec / 1000000;
   usec         -=  sec * 1000000;
   ticks.tv_sec  =  sec;
   ticks.tv_usec = usec;

   return ticks;
}



unsigned int TMR_ticks_to_usecs_nsecs (TMR_tick ticks)
/*
   DESCRIPTION
   -----------
   Convert a number of ticks to microsecond and nanoseconds. LINUX does
   not have a high resolution timer that exists in any natural units. Times
   must always to be converted to a 'timeval' structure. So given this, one
   just adopts nanoseconds.

   PARAMETERS
   ----------
        ticks: The number of ticks to convert

   RETURNS
   -------
   The equivalent number of microseconds, nanoseconds
*/
{
   TMR_usecs_nsecs unsecs;
   unsecs->usecs = ticks.tv_sec * 1000000 + ticks.tv_usec;
   unsecs->nsecs = 0;
   return unsecs;
} 



unsigned int TMR_ticks_to_nsecs (TMR_tick ticks)
/*
   DESCRIPTION
   -----------
   Convert a number of ticks to nanoseconds. LINUX does not have a high
   resolution timer that exists in any natural units. Times must always
   to be converted to a 'timeval' structure. So given this, one just 
   adopts nanoseconds.

   PARAMETERS
   ----------
        ticks: The number of ticks to convert


   RETURNS
   -------
   The equivalent number of nanoseconds
*/
{
   return ticks.tv_sec * 1000000000 + ticks.tv_usec * 1000;
} 



TMR_usecs_nsecs TMR_ticks_to_usecs_nsecs (TMR_tick ticks)
/*
   DESCRIPTION
   -----------
   Convert a number of ticks to microsecond and nanoseconds. LINUX does
   not have a high resolution timer that exists in any natural units. Times
   must always to be converted to a 'timeval' structure. So given this, one
   just adopts nanoseconds.

   PARAMETERS
   ----------
        ticks: The number of ticks to convert

   RETURNS
   -------
   The equivalent number of microseconds, nanoseconds
*/
{
   TMR_usecs_nsecs unsecs;
   unsecs->usecs = ticks.tv_sec * 1000000 + ticks.tv_usec;
   unsecs->nsecs = 0;
   return unsecs;
} 

   

unsigned int TMR_frequency (void)
/*
    DESCRIPTION
    -----------
    Returns the frequency, in Hertz, of the processor clock. This is the
    number of ticks/sec.

    PARAMETERS
    ----------
          NONE

    RETURNS
    -------
    The frequency in Hertz
*/
{   
    return 1000000000;
}

#endif
